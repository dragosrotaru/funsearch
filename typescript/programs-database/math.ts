import { ScoresPerTest } from "./types.ts";

// todo Verify logic generated by GPT
/**
 * Returns the tempered softmax of 1D finite `logits`.
 * @param logits
 * @param temperature
 * @returns
 */
export function softmax(logits: number[], temperature: number): number[] {
  if (!logits.every(Number.isFinite)) {
    const nonFinites = logits.filter((value) => !Number.isFinite(value));
    throw new Error(`logits contains non-finite value(s): ${nonFinites}`);
  }
  if (!logits.every((value) => typeof value === "number")) {
    logits = logits.map((value) => Number(value));
  }

  const result = logits.map((logit) => Math.exp(logit / temperature));

  const sum = result.reduce((acc, val) => acc + val, 0);
  const probabilities = result.map((value) => value / sum);

  // Ensure that probabilities sum to 1 to prevent errors in random choice.
  const index = probabilities.findIndex((prob) => prob > 0);
  if (index !== -1) {
    const remainingSum =
      1 - probabilities.slice(0, index).reduce((acc, val) => acc + val, 0);
    probabilities[index] = remainingSum;
  }

  return probabilities;
}

// todo Verify logic generated by GPT
export function getRandomWeightedIndex(probabilities: number[]): number {
  const randomValue = Math.random();
  let cumulativeProbability = 0;

  for (let i = 0; i < probabilities.length; i++) {
    cumulativeProbability += probabilities[i];
    if (randomValue <= cumulativeProbability) {
      return i;
    }
  }

  return probabilities.length - 1;
}

/**
 * Reduces per-test scores into a single score.
 * @param scoresPerTest
 * @returns
 */
export function reduceScore(scoresPerTest: ScoresPerTest): number {
  const testKeys = Object.keys(scoresPerTest);
  return scoresPerTest[testKeys[testKeys.length - 1]];
}
