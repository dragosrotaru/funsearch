import { Function } from "../code-manipulation/function.ts";
import { Program } from "../code-manipulation/program.ts";
import { missing } from "../code-manipulation/ast.ts";
import { FunctionLineVisitor } from "./functionLineVisitor.ts";
import { ProgramsDatabase } from "../programs-database/programsDatabase.ts";
import { Sandbox } from "./sandbox.ts";
import {
  getFunctionsCalled,
  renameFunctionCalls,
} from "../code-manipulation/parser.ts";

// Class for evaluating programs proposed by the Sampler.

/**
 * Extracts the body of the generated function, trimming anything after it.
 * @param generatedCode
 * @returns
 */
export function trimFunctionBody(generatedCode: string): string {
  if (!generatedCode) {
    return "";
  }
  let code = `def fake_function_header():\n${generatedCode}`;
  let tree = null;
  while (tree === null) {
    try {
      tree = missing.parse(code);
    } catch (e) {
      code = code
        .split("\n")
        .slice(0, e.lineno - 1)
        .join("\n");
    }
  }
  if (!code) {
    return "";
  }

  const visitor = new FunctionLineVisitor("fake_function_header");
  visitor.visit(tree);
  const bodyLines = code.split("\n").slice(1, visitor.endLine);
  return bodyLines.join("\n") + "\n\n";
}

/**
 * Returns the compiled generated function and the full runnable program.
 * @param generatedCode
 * @param versionGenerated
 * @param template
 * @param functionToEvolve
 * @returns
 */
function sampleToProgram(
  generatedCode: string,
  versionGenerated: number | null,
  template: Program,
  functionToEvolve: string
): [Function, string] {
  let body = trimFunctionBody(generatedCode);
  if (versionGenerated !== null) {
    body = renameFunctionCalls(
      body,
      `${functionToEvolve}_v${versionGenerated}`,
      functionToEvolve
    );
  }

  const program = missing.deepcopy(template);
  const evolvedFunction = program.get_function(functionToEvolve);
  evolvedFunction.body = body;
  return [evolvedFunction, program.toString()];
}

/**
 * Returns whether the generated function is calling an earlier version.
 * @param program
 * @param functionToEvolve
 * @returns
 */
function callsAncestor(program: string, functionToEvolve: string): boolean {
  for (const name of getFunctionsCalled(program)) {
    // In `program` passed into this function, the most recently generated
    // function has already been renamed to `functionToEvolve` (without the
    // suffix). Therefore, any function call starting with `functionToEvolve_v`
    // is a call to an ancestor function.
    if (name.startsWith(`${functionToEvolve}_v`)) {
      return true;
    }
  }
  return false;
}

/**
 * Class that analyses functions generated by LLMs.
 */
export class Evaluator {
  private sandbox = new Sandbox();

  constructor(
    private database: ProgramsDatabase,
    private template: Program,
    private functionToEvolve: string,
    private functionToRun: string,
    private inputs: any[],
    private timeoutSeconds: number = 30
  ) {}

  /**
   * Compiles the sample into a program and executes it on test inputs.
   * @param sample
   * @param islandId
   * @param versionGenerated
   */
  analyse(
    sample: string,
    islandId: number | null,
    versionGenerated: number | null
  ): void {
    const [newFunction, program] = sampleToProgram(
      sample,
      versionGenerated,
      this.template,
      this.functionToEvolve
    );

    const scoresPerTest: Record<string, number> = {};
    for (const currentInput of this.inputs) {
      const [testOutput, runsOk] = this.sandbox.run(
        program,
        this.functionToRun,
        currentInput,
        this.timeoutSeconds
      );
      if (
        runsOk &&
        !callsAncestor(program, this.functionToEvolve) &&
        testOutput !== null
      ) {
        if (typeof testOutput !== "number") {
          throw new Error("@function.run did not return a number.");
        }
        scoresPerTest[currentInput] = testOutput;
      }
    }
    if (Object.keys(scoresPerTest).length > 0) {
      this.database.registerProgram(newFunction, islandId, scoresPerTest);
    }
  }
}
